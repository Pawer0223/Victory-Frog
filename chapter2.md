# Chapter 2 자바와 절차적/구조적 프로그래밍

1. [자바 프로그램의 개발과 구동](#1-자바-프로그램의-개발과-구동)
2. [변수와 메모리: 변수! 너 어디 있니?](#2-변수와-메모리-변수-너-어디-있니)
3. [블록 구문과 메모리: 블록 스택 프레임](#3-블록-구문과-메모리-블록-스택-프레임)
4. [지역 변수와 메모리: 스택 프레임에 갇혔어요!](#4-지역-변수와-메모리-스택-프레임에-갇혔어요)
5. [메서드 호출과 메모리: 메서드 스택 프레임2](#5-메서드-호출과-메모리-메서드-스택-프레임2)
6. [전역 변수와 메모리: 전역 변수 쓰지 말라니까요!](#6-전역-변수와-메모리-전역-변수-쓰지-말라니까요)
7. [멀티 스레드 / 멀티 프로세스의 이해](#7-멀티-스레드--멀티-프로세스의-이해)

## 1. 자바 프로그램의 개발과 구동

* JDK(Java Development Kit) : 자바 개발 도구
* JRE(Java Runtime Environment) : 자바 실행 환경
* JVM(Java Virtual Machine) : 자바 가상 기계

JVM ∈ JRE ∈ JDK 인 관계가 성립한다. JDK는 javac.exe를 사용하여 자바 소스를 컴파일해 목적 파일인 class 파일을 생성해내고, JRE는 java.exe를 사용해 클래스 파일을 실행한다.
자바가 JDK, JRE, JVM과 같은 환경을 채택한 이유는 하드웨어와 OS의 조합에 맞게 각 플랫폼마다 다른 설치파일을 준비해야 했던 불편함을 없애기 위해서이다.**(Write Once Run Anywhere)**

### 프로그램이 메모리를 사용하는 방식

* Code
* Data(T 메모리 구조)
    * Static : 클래스의 놀이터
    * Stack : 메소드의 놀이터
    * Heap : 객체의 놀이터

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산

1. goto 쓰지 마라 : 프로그램의 실행 순서가 복잡해짐. (스파게티 코드)
2. 함수 써라 : 중복 코드 제거와 논리의 분할을 위해
3. 전역변수보다 지역 변수를 써라 : 전역 변수는 공유 사용 시 문제가 발생하기 쉽다

### 다시 보는 main() 메서드 : 메서드 스택 프레임

#### main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들
* java.lang 패키지를 T 메모리 스태틱 영역에 배치
* import된 패키지를 T 메모리 스태틱 영역에 배치
* 프로그램 상의 모든 클래스를 T 메모리의 스태틱 영역에 배치

모든 메서드는 스택 영역에서 스택 프레임을 생성되고, 호출이 끝나면 프레임이 소멸된다.

<br/>

## 2. 변수와 메모리: 변수! 너 어디 있니?

* 메서드 내의 지역 변수는 해당 메서드의 스택 프레임 내에 밑에서부터 메모리가 할당됨.
* 변수는 선언하는 명령문과 값을 할당하는 명령문으로 나눠서 실행됨.

<br/>

## 3. 블록 구문과 메모리: 블록 스택 프레임

### if 블록

```java
public class Start3{
  puvlic static void main(String[] args){
    int i=10;
    if(i==10){
    
    }else{
    
    }
  }
}
```

* 스택 프레임 내에 스택 프레임이 중첩되어 생긴다.
    * 예시와 같은 경우 if(true)인 스택 프레임이 main() 스택 프레임 내에 생성됨.
    * 즉, 재귀와 같은 경우는 스택 내에 프레임이 지속적으로 중첩되어 생기기 때문에 무한으로 호출될 경우 스택 오버플로우가 생길 수 있음.

* 실행 지점이 블록 스코프를 벗어나게 되면 해당 스택 프레임이 소멸된다.
* main()이 종료되면 T 메모리 소멸, JVM 기동 중지, JRE가 사용한 시스템 자원 OS에 반납의 절차가 일어남.

<br/>

## 4. 지역 변수와 메모리: 스택 프레임에 갇혔어요!

* 지역 변수 : 스택 프레임 내에 생성되고, 스택 프레임 소멸 시 같이 소멸됨.
* 클래스 멤버 변수 : 스태틱 영역 내에 생성되고, JVM이 종료되기 전까지 소멸되지 않음.
* 객체 멤버 변수 : 힙에서 생성되고, 가비지 컬렉터가 객체를 힙에서 회수시 같이 소멸됨.

지역 변수는 그 변수가 생성된 스택 프레임에서만 사용할 수 있고 외부에서는 사용할 수 없다.  
내부 지역에서 외부 지역의 변수를 사용하는 것은 가능하지만, 그 반대는 안됨.

<br/>

## 5. 메서드 호출과 메모리: 메서드 스택 프레임2

메서드 호출이 일어나면 호출되는 메서드의 스택 프레임이 T 메모리의 스택 영역에 새로 생성되고, 반환값과 매개변수가 차례대로 스택 프레임 내에서 메모리가 할당된다.


### Call By Value

* 메인 메서드 내의 지역변수를 메서드의 매개변수로 사용한다고 해서 같은 변수가 아님.
* 매개변수와 지역변수 모두 서로 다른 스택 프레임 내에서 별도의 변수 공간을 가지게 되기 때문에 서로 독립적이다.
* 같은 값이 복사되어서 다른 공간에 할당되는 것임.

### 스택 프레임 사이의 접근

메서드 스택 프레임에서 다른 메서드 스택 프레임의 내부 변수는 접근이 불가하다.  
메서드 사이에 소통하는 방법은 메서드의 매개변수와 반환값말고는 없다.

1. 메서드는 서로의 고유 공간이다.
2. 호출된 메서드에서 호스트의 지역변수에 접근하려면 메모리값을 알아야하기 때문에 포인터가 필요하다.
3. 자바에서는 포인터를 사용할 수 없다.

<br/>

## 6. 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!

메서드 사이에 매개변수와 반환값 외의 방법으로 값을 공유하는 방법 : 전역 변수
* 지역 변수 : 스택 프레임에 종속적임
* 전역 변수 : 스택 프레임에 독립적임

### 잘 쓰지 않는 이유

* 여러 메서드에서 전역 변수 값을 변경하기 시작하면 전역 변수에 저장돼 있는 값을 파악하기 어려워짐.
* 읽기 전용으로 전역 상수로써 활용하는 것은 추천됨.
* 쓰기 가능한 전역 변수를 사용하게 되면 thread-safe 하지 않게됨.

<br/>

## 7. 멀티 스레드 / 멀티 프로세스의 이해

### 멀티 스레드(Multi Thread)
* 스택 영역을 스레드 개수만큼 분할함
* 스태틱 영역과 힙 영역은 공유해서 사용하기 때문에 메모리를 적게 사용할 수 있다.
* thread-safe를 위해 락을 통해 전역 변수를 write하면 멀티 스레드의 장점은 버리게 됨.

### 멀티 프로세스(Multi Process)
* 다수의 T 메모리를 갖는 구조임.
* 서로 참조할 수 없다.
* 메모리 사용량은 그만큼 크다.

