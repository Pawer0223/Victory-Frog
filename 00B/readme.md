# 자바8 람다와 인터페이스 스펙변화

## 람다가 도입된 이유

- 과거와 다르게 점점 멀티 코어를 활용한 분산 처리, 즉 병렬화 기술이 요구되었다.
- 더불어 CPU에 다수의 코어를 삽입하는 멀티 코어 프로세스들이 등장하면서 일반 프로그래머에게도 병렬화 프로그래밍에 대한 필요성이 생기기 시작했다.
- 이러한 추세에 대응하기 위해 자바8에서는 병렬화를 위해 컬렉션을 강화했다.(배열, List, Set, Map)
- 이러한 컬렉션을 더 효율적으로 사용하기 위해 스트림(Stream)을 강화했다.
- 또 스트림을 효율적으로 사용하기 위해 함수형 프로그래밍이 강화
- 다시 함수형 프로그래밍을 위해 람다가, 또 람다를 위해 인터페이스의 변화가 수반됐다.
- `람다를 지원하기 위한 인터페이스를 함수형 인터페이스라고 한다.`

> 물론 람다의 도입이나 함수형 인터페이스 도입이 빅데이터만을 위한 것은 아니지만 가장 주된 이유라고 봐도 무방할 것이다.

## 람다란 무엇인가 ?
- 한 마디로 코드 블록이다.
- 기존의 코드 블로은 반드시 메서드 내에 존재해야 했다.
- 코드 블록인 람다를 메서드의 이낮나 반환값으로 사용할 수 있게 됐다.

## 함수형 인터페이스
- 추상 메서드를 하나만 갖는 인터페이스를 자바8부터는 함수형 인터페이스라고 한다.
- 이런 함수형 인터페이스만을 람다식으로 변경할 수 있다.

## 자바8 API에서 제공하는 함수형 인터페이스
- [참조](https://codechacha.com/ko/java8-functional-interface/)

## 컬렉션 스트림에서 람다 사용
- 람다는 다양한 용도가 있지만 그 중에서도 컬렉션 스트림을 위한 기능에 크게 초점이 맞춰져 있다.
- 스트림을 활용하면 SQL구문과 유사하게 How가 아닌 What을 지정해서 프로그래밍 할 수 있다.
- 스트림은 고객의 요구를 선언적으로 코딩할 수 있는 힘을 준다.
  - 의사소통 내용 자체가 코드로 구현되는 것이 선언적 프로그래밍의 장점이다.

## 메서드 레퍼런스와 생성자 래퍼런스
- 메서드 레퍼런스에는 다음과 같은 세 가지 유형이 있다.
  - `인스턴스::인스턴스메서드`
    - 인스턴스 메서드의 인자가 된다
  - `클래스::정적메서드`
    - 정적 메서드의 인자가 된다
  - `클래스::인스턴스메서드`
    - 첫 번째 인자는 인스턴스가 되고, 그 다음 인자(들)는 인스턴스 메서드의 인자(들)가 된다.
    - `(a, b) -> a.compareTo(b)`-> `Integer::compareTo`

- 생성자 레퍼런스
  - `클래스::new`

## 인터페이스의 디폴트 메서드와 정적 메서드

- 디폴트 메서드
  - 구체 인스턴스 메서드(즉, 몸체를 가진 인스턴스 메서드)
  - default 키워드 사용

- (구체) 정적 메서드
  - 구체 메서드에 static을 붙여서 사용할 수 있다.

- 그럼 왜 자바8 API 설계자들은 인터페이스에 디폴트 메서드와 정적메서드를 추가했을까??
  - 컬렉션 API를 강화하면 컬렉션의 공통 조상인 Collection의 슈퍼 인터페이스인 Iterable 인터페이스에 많은 변화가 필요했다.
  - 한 예로 내부 반복을 가능하게 하는 forEach의 도입이 있다.
  - 그런데 인터페이스에 변화를 주게 되면, 즉 새로운 추상 인스턴스 메서드를 추가하게 되면 기존에 해당 인터페이스를 구현한 모든 사용자 정의 클래스는 이를 추가적으로 구현해야하만 한다.
  - 이에 따라 자바8 API 설계자들은 ㄹ
## 자바8 API에서 제공하는 함수형 인터페이이
## 자바8 API에서 제공하는 함수형 인터페이스



ㅇ
## 자바8 API에서 제공하는 함수형 인터페이ㅣ
## 자바8 API에서 제공하는 함수형 인터
