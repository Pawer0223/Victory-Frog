# 객체지향 설계 5원칙 - SOLID
- 객체 지향이 1960년 발표되고 수많은 시행착오와 베스트 프랙티스 속에서 객체 지향 설계(Object Oriented Design)의 정수라 할 수 있는 5원칙이 집대성 됐는데, 바로 `SOLID`다
    - SRP(Single Responsibilitiy Principle): 단일 책임 원칙
    - OCP(Open Closed Principle): 개방 폐쇄 원칙
    - LSP(Liskov Substitution Principle): 리스코프 치환 원칙
    - ISP(Interface Segeregationo Principle): 인터페이스 분리 원칙
    - DIP(Dependency Inversion Principle): 의존 역전 원칙

- `응집도는 높이고(High Cohesion), 결합도는 낮추라(Loose Coupling)`는 고전 원칙을 객체 지향의 관점에서 재정립한 것이라고 할 수 있다.
    - 결합도는 모듈(클래스) 간 상호 의존 정도.
        - 결합도가 낮으면 의존성이 줄어 객체의 재사용 및 유지보수가 용이
        - 결합도 수준: 데이터, 스탬프, 컨트롤, 외부, 공유, 내용 결합도
    - 응집도는 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성
        - 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용 및 유지보수가 용이
        - 기능, 순차, 통신, 절차, 시간, 논리, 우연 응집도

> SOLID는 객체 지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용되는 것이기에 막상 SOLID가 적용됐는지 아닌지 애매모호하거나 보는 사람의 관점에 따라 다르게 해석될 수 있는 소지가 있다. SOLID 자체는 제품이 아닌 개념이기 때문이다.

### SOLID는 객체 지향 4대 특성을 발판으로 하고 있으며, 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이기도 하다.

## SRP - 단일 책임 원칙
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

## OCP - 개방 폐쇄 원칙
> 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
> 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

- 개방 폐쇄 원칙을 따르지 않는다고 해서 객체 지향 프로그램을 구현하는 것이 불가능한 것은 아니지만 개방 폐쇄 원칙을 무시하고 프로그램을 작성하면 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다. 따라서 객체 지향 프로그래밍에서 개방 폐쇄 원칙은 반드시 지켜야 할 원칙이다.

- JDBC
    - JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 connection을 설정하는 부분 위에는 따로 수정할 필요가 없다.

- 자바에도 OCP가 적용돼 있다.
    - 자바개발자는 소스코드가 어느 운영체제에서 동작할지 걱정하지 않는다.
    - 각 운영체제별 JVM과 목적파일이 있기에 개발자는 다양한 구동 환경에 대해서는 걱정하지 않아도 된다.
    - 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀 있고, 각 운영체제별 JVM은 확장에 열려 있는 구조가 되는 것이다.
        - 개발자의 소스코드와 운영체제별 JVM 사이에는 목적파일이라고 하는 완충 장치가 있는 것이다.

## LSP - 리스코프 치환 원칙
> 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.
> 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.

- 아래 두 문장대로 구현되었다면 LSP를 잘 지키고 있다고 할 수 있다. 하지만 상속이 조직도나 계층도 형태로 구축되는 경우 아래 문장처럼 구현되지 않을 수 있다.
    - 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다
    - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
        - ex) AutoCloseable: 자동으로 닫힐 수 있어야 한다. , Appendable - 덧붙일 수 있어야 한다.

- 아빠와 딸에 대한 상속관계는 LSP 위반이다.
    - 이상하다.
``` java
아버지 춘향이 = new 딸();
```

- 결국 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다.

## ISP - 인터페이스 분리 원칙
> 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

### 단일 책인 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.

- 프로젝트 요구사항과 설계자의 취향에 따라 단일 책인 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
- 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.
- 인터페이스 분할 원칙을 이야기 할 때 항상 함께 등장하는 원칙 중 하나로 `인터페이스 최소주의 원칙`이라는 것이 있다.
    - 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라.

## DIP - 의존 역전 원칙
> 고차원 모듈은 저차원 모듈에 의존하면 안된다. <br>
> 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다. <br>
> 추상화된 것은 구체적인 것에 의존하면 안 된다. <br>
> 구체적인 것이 추상화된 것에 의존해야 한다. <br>
> 자주 변경되는 구체 클래스에 의존하지 마라

- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.

### 자신보다 변하기 쉬운 것에 의존하지 마라.

- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이 바로 의존 역전 원칙이다.

## 정리
- SOLID는 많은 시행착오를 겪어 나온 개념이기 때문에, 객체 지향 4대 특성을 제대로 활용한 결과로 당연히 나타나는 것이다.
    - 따라서 객체지향 4대 특성을 제대로 이해해야 SOLID를 제대로 이해하고 활용할 수 있음을 기억하자.
- SOLID를 이야기할 때 빼놓을 수 없는 것이 SoC다.
    - SoC: 관심사의 분리(Separation Of Concerns)
    - 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능 한 따로 떨어져 서로 영향을 주지 않도록 분리하라는 것.
    - 관심사가 다르고 변화의 시기가 다르면 분리해야 한다는 것.
- SoC를 적용하면 자연스럽게 단일 책임 원칙(SRP), 인터페이스 분리 원칙(ISP), 개방 폐쇄 원칙(OCP)에 도달하게 된다. 스프링 또한 SoC를 통해 SOLID를 극한까지 적용하고 있다.

### SRP(Single Responsibilitiy Principle): 단일 책임 원칙
- 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
### OCP(Open Closed Principle): 개방 폐쇄 원칙
- 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
### LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
### ISP(Interface Segeregationo Principle): 인터페이스 분리 원칙
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
### DIP(Dependency Inversion Principle): 의존 역전 원칙
- 자신보다 변하기 쉬운 것에 의존하지 마라.
